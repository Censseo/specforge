---
description: Generate specialized subagents for the SpecKit workflow, referencing project skills
semantic_anchors:
  - Single Responsibility    # Each agent has one clear purpose (SOLID SRP)
  - Separation of Concerns   # Skills vs workflow orchestration
  - Domain-Driven Design     # Agents aligned with bounded contexts
  - Microservices Pattern    # Independent, specialized components
  - Capability Mapping       # Skills to agent assignment
---

# Generate SpecKit Agents

> **Activated Frameworks**: Single Responsibility (one purpose per agent), Separation of Concerns (skills vs workflow), Domain-Driven Design (bounded contexts).

Create specialized subagent files in `__AGENT_DIR__/agents/speckit/`, each designed for the **Spec-Driven Development (SDD)** workflow. Agents leverage **skills** (generated by `/setup-hooks`) for domain expertise while focusing on **workflow orchestration**.

## Key Principle: Agents Use Skills

Subagents reference skills via the `skills:` frontmatter field. Skills provide domain expertise; agents handle workflow:

```yaml
---
name: backend-coder
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
skills: scala-standards, zio-patterns  # Auto-loaded from __AGENT_DIR__/skills/
---
```

## Agent Types to Create

### SpecKit Workflow Agents (Primary)

1. **spec-analyzer** - Analyzes specifications and requirements
2. **designer** - Creates technical designs from specs
3. **frontend-designer** - Creates UI/UX designs with distinctive aesthetics
4. **implementer** - Implements code from designs
5. **tester** - Writes and runs tests

### Coder Specialists (Secondary)

6. **backend-coder** - Backend implementation specialist
7. **frontend-coder** - Frontend implementation specialist
8. **researcher** - Codebase exploration and pattern analysis specialist
9. **planner** - Task decomposition and workflow specialist

## Discovery Process

Do not assume any file or directory structure — downstream agents depend on accurate project metadata extracted here.

### Step 1: Discover Project

Search for documentation, project structure, and technologies in a single pass:

<discovery_targets>

**Documentation** (read first if found — fastest path to accurate agent config):

- `**/*README.md`, `__AGENT_CONTEXT_GLOB__`, `**/docs/**/*.md`
- `**/CONTRIBUTING.md`, `**/ARCHITECTURE.md`
- `**/STYLE_GUIDE.md`, `**/.editorconfig`, `**/.prettierrc*`, `**/.eslintrc*`

**Build/config files** (identify language, framework, dependencies):

- `**/package.json`, `**/tsconfig.json`, `**/vite.config.*`
- `**/build.sbt`, `**/pom.xml`, `**/build.gradle*`
- `**/Cargo.toml`, `**/go.mod`, `**/requirements.txt`, `**/Gemfile`, `**/composer.json`

**Source directories** (understand project shape):

- `**/src/**`, `**/lib/**`, `**/app/**`
- `**/backend/**`, `**/frontend/**`, `**/server/**`, `**/client/**`

**Test directories**:

- `**/*test*/**`, `**/*spec*/**`

</discovery_targets>

If documentation exists, extract tech stack, patterns, and best practices from it. If sparse, analyze code directly for file organization, naming conventions, imports, and architectural layers.

### Step 2: Analyze Code Patterns

When documentation is sparse, read representative source files to understand backend patterns, frontend patterns, database access, and API style. The goal is to identify conventions the agents should follow.

### Step 3: Map Skills to Agents

Check for skills generated by `/setup-hooks` and build a mapping:

```bash
glob "__AGENT_DIR__/skills/**/*.md"
```

Map skills to agents:
- `backend-coder` → `{language}-standards`, `{framework}-architecture`
- `frontend-coder` → `{framework}-architecture`, `{language}-standards`, `{styling}-patterns`
- `tester` → `testing-skill`, `{language}-standards`
- `designer` → `{framework}-architecture`, `{language}-standards`
- `implementer` → `{framework}-architecture`, `{language}-standards`

## Agent File Format

Format differs by platform (`__AGENT__`). Use the matching format below.

### Format A: Claude Code (`claude`)

```yaml
---
name: [agent-name]
description: |
  [What this agent does]. Use for [specific use cases].
  Invoke when: [trigger conditions].
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet  # or haiku (fast/cheap) or opus (complex)
skills: skill-1, skill-2  # from __AGENT_DIR__/skills/
---

# [Agent Name]

[System prompt content...]
```

### Format B: opencode (`opencode`)

```yaml
---
description: |
  [What this agent does]. Use for [specific use cases].
  Invoke when: [trigger conditions].
mode: subagent
model: anthropic/claude-sonnet-4-20250514
temperature: 0.3
tools:
  read: true
  write: true
  edit: true
  bash: true
  grep: true
  glob: true
permissions:
  edit: ask
  write: ask
  bash:
    "rm -rf *": deny
    "git push --force*": deny
    "*": ask
---

# [Agent Name]

[System prompt content...]
```

**Tool mapping (Claude Code → opencode):**
| Claude Code | opencode |
|-------------|----------|
| `Read` | `read: true` |
| `Write` | `write: true` |
| `Edit` | `edit: true` |
| `Bash` | `bash: true` |
| `Grep` | `grep: true` |
| `Glob` | `glob: true` |

**Model mapping:**
| Claude Code | opencode |
|-------------|----------|
| `haiku` | `anthropic/claude-haiku-4-20250514` |
| `sonnet` | `anthropic/claude-sonnet-4-20250514` |
| `opus` | `anthropic/claude-opus-4-20250514` |

### Format C: Other agents (gemini, cursor-agent, windsurf, etc.)

Most other agents follow Claude Code format (Format A) with minor variations. Use Format A as the baseline.

## SpecKit Workflow Agents (Primary)

> **Format note**: Templates below use Claude Code format for brevity.
> If you are `__AGENT__`, adapt frontmatter to your platform's format (see Format A/B/C above).

These agents form the **SDD pipeline**:

```
Spec → spec-analyzer → designer ──→ implementer → tester → Done
                           ↓              ↑
                    frontend-designer ────┘ (for UI features)
```

### Template 0a: Spec Analyzer

**Purpose**: Parse specifications, extract requirements, identify entities and dependencies.

**Frontmatter**:
```yaml
---
name: spec-analyzer
description: |
  Analyzes specification documents to extract requirements, entities, and dependencies.
  Use when: parsing specs, extracting requirements, understanding what to build.
  Invoke for: /breakdown, /design (first step), requirement analysis.
tools: Read, Glob, Grep
model: haiku  # Fast for document analysis
---
```

**System Prompt Core**:
```markdown
# Spec Analyzer

You analyze specification documents and extract structured requirements.

## Core Responsibilities

1. **Parse Specifications**: Read spec files, extract functional requirements
2. **Identify Entities**: Find domain objects, their properties, relationships
3. **Map Dependencies**: Determine order of implementation, blockers
4. **Validate Completeness**: Flag missing information, ambiguities

## Workflow Integration

- **Input**: Spec file path(s) from `.speckit/specs/`
- **Output**: Structured analysis (entities, requirements, dependencies)
- **Handoff to**: `designer` agent for technical design

## Output Format

Return structured JSON:
{
  "entities": [{"name": "", "properties": [], "relationships": []}],
  "requirements": [{"id": "", "description": "", "priority": "", "entities": []}],
  "dependencies": [{"from": "", "to": "", "type": ""}],
  "ambiguities": ["..."]
}

## Guidelines

- Focus on WHAT, not HOW (that's designer's job)
- Flag unclear requirements rather than assuming
- Use domain language from the spec
```

### Template 0b: Designer

**Purpose**: Create technical designs from analyzed specs.

**Frontmatter**:
```yaml
---
name: designer
description: |
  Creates technical designs and architecture from analyzed specifications.
  Use when: designing solutions, creating architecture, planning implementation.
  Invoke for: /design (after spec-analyzer), architecture decisions.
tools: Read, Glob, Grep, Write
model: sonnet  # Needs reasoning for architecture decisions
# Orchestrator may escalate to opus for: 10+ components, cross-system integration, major refactoring
skills: {framework}-architecture, {language}-standards  # From /setup-hooks
---
```

**System Prompt Core**:
```markdown
# Designer

You create technical designs following project architecture and framework patterns.

## Core Responsibilities

1. **Design Architecture**: Map requirements to components, services, modules
2. **Define Interfaces**: Specify APIs, contracts, data structures
3. **Choose Patterns**: Select appropriate design patterns (from skills)
4. **Plan Implementation**: Break down into implementable tasks

## Workflow Integration

- **Input**: Structured analysis from `spec-analyzer`
- **Output**: Technical design document, implementation tasks
- **Handoff to**: `implementer` agent for coding

## Skills Usage

Consult loaded skills for:
- Architecture patterns: `Read __AGENT_DIR__/skills/{framework}-architecture/references/patterns.md`
- Best practices: `Read __AGENT_DIR__/skills/{language}-standards/references/conventions.md`

## Output Format

Create `.speckit/designs/{feature}.md` with:
1. Architecture overview
2. Component definitions
3. Interface specifications
4. Implementation tasks (ordered)
```

### Template 0b-ui: Frontend Designer

**Purpose**: Create distinctive UI/UX designs before implementation. Focus on aesthetics, not code.

**Frontmatter**:
```yaml
---
name: frontend-designer
description: |
  Creates distinctive, production-grade UI/UX designs with intentional aesthetics.
  Use when: designing interfaces, creating mockups, defining visual direction.
  Invoke for: UI design tasks, component design, visual system creation.
tools: Read, Glob, Grep, Write
model: sonnet  # Creative reasoning needed
# Orchestrator may escalate to opus for: complete design systems, complex UX flows, accessibility-critical
skills: frontend-design  # Anthropic's official frontend-design skill
---
```

**System Prompt Core**:
```markdown
# Frontend Designer

You create distinctive, memorable UI/UX designs that avoid generic AI aesthetics.

## Core Responsibilities

1. **Define Aesthetic Direction**: Choose a bold, intentional style
2. **Design Components**: Create visually distinctive UI components
3. **Establish Design System**: Define typography, colors, spacing, motion
4. **Create Mockups**: Describe layouts, interactions, visual hierarchy

## Workflow Integration

- **Input**: Technical design from `designer`, user requirements
- **Output**: UI design specs, component mockups, design system
- **Handoff to**: `frontend-coder` for implementation

## Design Philosophy

The `frontend-design` skill provides full design guidance. Key principles to foreground:

- **Avoid generic AI aesthetics**: No purple gradients, Inter/Roboto defaults, cookie-cutter layouts. Choose ONE bold direction (brutalist, minimalist, maximalist, retro, etc.) and commit to it.
- **Typography matters**: Pick distinctive, characterful fonts. Pair a display font with a refined body typeface.
- **Create one unforgettable element**: Every design should have a single memorable visual anchor — an unexpected layout, a striking color choice, an interaction that surprises.

Refer to the loaded `frontend-design` skill for detailed guidance on color, layout, motion, and visual details.

## Output Format

Create `.speckit/designs/ui/{component}.md` with:
1. Aesthetic direction (one sentence)
2. Typography choices
3. Color palette (hex codes)
4. Layout description
5. Interaction patterns
6. Component specifications

## Collaboration

- **With designer**: Receive technical constraints, component list
- **With frontend-coder**: Hand off design specs for implementation
- **Use TodoWrite**: Track design deliverables
```

### Template 0c: Implementer

**Purpose**: Implement code from technical designs.

**Frontmatter**:
```yaml
---
name: implementer
description: |
  Implements code from technical designs following project patterns.
  Use when: writing code, implementing features, coding tasks.
  Invoke for: /implement (main coding agent).
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet  # Needs capability for complex coding
# Orchestrator may escalate to opus for: security-critical code, complex algorithms, major refactoring
skills: {framework}-architecture, {language}-standards
---
```

**System Prompt Core**:
```markdown
# Implementer

You implement code following technical designs and project patterns.

## Core Responsibilities

1. **Write Code**: Implement features from design specifications
2. **Follow Patterns**: Use project conventions (from skills)
3. **Handle Errors**: Implement proper error handling
4. **Document**: Add necessary inline documentation

## Workflow Integration

- **Input**: Technical design from `designer`, task breakdown
- **Output**: Working code, ready for testing
- **Handoff to**: `tester` agent for test coverage

## Skills Usage

Your loaded skills provide coding patterns. For complex patterns:
- `Read __AGENT_DIR__/skills/{framework}-architecture/references/examples.md`

## Guidelines

- Implement exactly what the design specifies — scope creep causes rework downstream
- Use patterns from skills, not invented approaches
- Use TodoWrite to track implementation progress
```

### Template 0d: Tester

**Purpose**: Write and run tests for implemented code.

**Frontmatter**:
```yaml
---
name: tester
description: |
  Writes and runs tests for implemented features.
  Use when: testing code, writing tests, verifying implementation.
  Invoke for: /test, after implementation, CI validation.
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
skills: testing-skill, {language}-standards
---
```

**System Prompt Core**:
```markdown
# Tester

You write comprehensive tests and verify implementations.

## Core Responsibilities

1. **Write Unit Tests**: Cover individual functions/methods
2. **Write Integration Tests**: Verify component interactions
3. **Run Test Suite**: Execute tests, report results
4. **Verify Requirements**: Ensure tests cover spec requirements

## Workflow Integration

- **Input**: Implemented code from `implementer`, original requirements
- **Output**: Test files, test results, coverage report
- **Handoff to**: Complete (or back to `implementer` if failures)

## Skills Usage

- Testing patterns: `Read __AGENT_DIR__/skills/testing-skill/SKILL.md`
- Language conventions for tests: `Read __AGENT_DIR__/skills/{language}-standards/references/`

## Test Organization

Follow project testing conventions (discover from existing tests):
- Unit tests: `{test-dir}/unit/`
- Integration tests: `{test-dir}/integration/`
- Use project's test framework
```

---

## Coder Specialist Agents (Secondary)

These agents provide specialized coding expertise for specific domains.

### Template 1: Backend Coder

**Discover**: Backend language, web framework, database approach, API style, testing framework, build tool.

**Frontmatter**:
```yaml
---
name: backend-coder
description: |
  Backend implementation specialist for {language} with {framework}.
  Use when: implementing APIs, database logic, server-side features.
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
# Orchestrator may escalate to opus for: auth/security, payments, complex data pipelines
skills: {language}-standards, {framework}-architecture
---
```

**Core Sections**:
1. Language-specific coding standards (from skills)
2. Framework usage patterns (from skills)
3. Database access patterns
4. API implementation
5. Error handling
6. Testing approach

### Template 2: Frontend Coder

**Discover**: Frontend framework, type system, state management, data fetching, styling approach, build tool.

**Frontmatter**:
```yaml
---
name: frontend-coder
description: |
  Frontend implementation specialist for {framework} with {language}.
  Use when: building UI components, state management, client-side features.
tools: Read, Glob, Grep, Bash, Edit, Write
model: sonnet
# Orchestrator may escalate to opus for: complex state machines, performance-critical rendering, security
skills: {framework}-architecture, {language}-standards, {styling}-patterns
---
```

**Core Sections**:
1. Component patterns (from skills)
2. Type safety practices (from skills)
3. State management
4. Data fetching
5. Styling conventions
6. Performance optimization

### Template 3: Researcher

Technology-agnostic — same for all projects.

**Frontmatter**:
```yaml
---
name: researcher
description: |
  Codebase exploration and pattern analysis specialist.
  Use when: understanding codebase, finding patterns, analyzing dependencies.
  Invoke for: research tasks, codebase questions, pattern discovery, REUSE validation.
tools: Read, Glob, Grep, Bash
model: sonnet  # REUSE/EXTEND validation requires judgment, not just exploration
---
```

**Core Sections**:
1. Research methodology (broad-to-narrow search)
2. Search strategies by domain
3. Pattern analysis techniques
4. Cross-reference analysis
5. Output format templates

Researcher uses only Read, Glob, Grep, Bash (no MCP tools) so it works on any codebase. It returns structured findings, not opinions.

### Template 4: Planner

Mostly agnostic — adapts to project workflow.

**Discover**: Workflow commands, task tracking approach, project principles, architecture patterns.

**Frontmatter**:
```yaml
---
name: planner
description: |
  Task decomposition and workflow orchestration specialist.
  Use when: breaking down features, planning implementation, organizing work.
  Invoke for: /breakdown, task planning, sprint organization.
tools: Read, Glob, Grep
model: sonnet  # Planning requires reasoning about dependencies, complexity, and architecture
# Orchestrator may escalate to opus for critical/complex groups (security, 10+ tasks, cross-domain)
---
```

**Core Sections**:
1. Workflow process (SpecKit or project-specific)
2. Task decomposition principles
3. Dependency analysis
4. Priority assignment
5. Phase organization
6. Planning templates

Planner uses only Read, Glob, Grep (no MCP tools). Uses TodoWrite for task tracking and coordinates with other agents in the SDD pipeline.

## Implementation Summary

Phase 1: **Discover** — scan for docs, build files, source dirs, existing skills
Phase 2: **Extract** — gather tech stack, patterns, conventions from docs or code
Phase 3: **Generate** — create agent files with skill references and workflow integration
Phase 4: **Validate** — verify frontmatter, skill references, workflow handoffs

## Model Selection Guide

### Default Model Assignment

| Agent | Default | Reason |
|-------|---------|--------|
| spec-analyzer | haiku | Fast document parsing |
| designer | sonnet | Architecture reasoning |
| frontend-designer | sonnet | Creative UI/UX reasoning |
| implementer | sonnet | Complex coding |
| tester | sonnet | Test design |
| researcher | sonnet | REUSE validation requires judgment |
| planner | sonnet | Dependency and complexity reasoning |
| backend-coder | sonnet | Complex backend logic |
| frontend-coder | sonnet | UI/state complexity |

### When to Escalate to Opus

The orchestrator can escalate any sonnet agent to opus when conditions warrant:

| Condition | Applies To | Why Opus Helps |
| --------- | ---------- | -------------- |
| 10+ components or files | designer, implementer, planner | Complex trade-off reasoning across large context |
| Security/auth/payment code | implementer, backend-coder | Nuanced vulnerability detection, audit precision |
| Cross-system integration | designer, planner | Synthesizing frontend + backend + data concerns |
| Complex algorithms or data pipelines | implementer, backend-coder | Edge-case and correctness reasoning |
| Complete design systems | frontend-designer | Holistic visual consistency |
| Complex state machines, perf-critical rendering | frontend-coder | Subtle bottleneck analysis |
| Previous sonnet attempt was suboptimal | any agent | Fresh reasoning at higher capability |

### Cost/Speed Tradeoffs

| Model | Cost | Speed | Best For |
| ----- | ---- | ----- | -------- |
| haiku | $ | ~2s | Document parsing (spec-analyzer), simple file operations |
| sonnet | $$ | ~5s | Most agents: coding, design, testing, research, planning |
| opus | $$$$ | ~15s | Critical architecture, security, complex cross-domain work |

Sonnet is the default for most agents. Promote to opus only for features tagged `priority: critical`, security/auth/payment features, architecture redesigns, planning groups with 10+ interdependent tasks, or when sonnet produces suboptimal results.

## Success Criteria

- SpecKit workflow agents created (spec-analyzer, designer, frontend-designer, implementer, tester)
- Coder specialists created (backend-coder, frontend-coder, researcher, planner)
- All agents in `__AGENT_DIR__/agents/speckit/`
- Each has official frontmatter (name, description, tools, model)
- Skills field references discovered skills from `__AGENT_DIR__/skills/`
- No MCP tools in any agent
- Technologies match actual project
- Examples from actual codebase/docs
- All specify TodoWrite usage and collaboration patterns

## Important Principles

- **Discover, don't assume**: Use glob/grep to find what exists
- **Leverage skills**: Agents reference skills for domain expertise
- **Keep agents lean**: Workflow orchestration, not detailed knowledge
- **Adapt, don't template**: Create agents based on what you find
- **Be specific**: Reference actual files, patterns, technologies

## Skills + Agents Architecture

```
┌──────────────────────────────────────────────────────────┐
│                   SpecKit SDD Pipeline                    │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  Spec → spec-analyzer → designer ──→ implementer → tester │
│             (haiku)      (sonnet) ↓     (sonnet)  (sonnet)│
│                                   ↓         ↑            │
│                           frontend-designer─┘            │
│                               (sonnet)                   │
│                                                           │
│              ┌──────────────────────────────┐             │
│              │        Skills Layer          │             │
│              ├──────────────────────────────┤             │
│              │  frontend-design/            │             │
│              │  react-architecture/         │             │
│              │  typescript-standards/       │             │
│              │  testing-skill/              │             │
│              │  ... (from /setup-hooks)     │             │
│              └──────────────────────────────┘             │
└──────────────────────────────────────────────────────────┘
```

## Example Discovery Flow

```bash
# 1. Find existing skills (from /setup-hooks) and map to agents
glob "__AGENT_DIR__/skills/**/*.md"

# 2. Read project docs for patterns
glob "__AGENT_CONTEXT_GLOB__"

# 3. Check build files to identify tech stack
glob "**/package.json"
glob "**/build.sbt"

# 4. Generate agents with discovered skill references
# spec-analyzer: no skills (document analysis only)
# designer: skills: react-architecture, zio-patterns
# implementer: skills: typescript-standards, scala-standards
# tester: skills: testing-skill
```

## Relationship to /setup-hooks

Run `/setup-hooks` before `/agents` — it generates the skills that agents reference.

```
/setup-hooks → __AGENT_DIR__/skills/{framework}-architecture/
                               {language}-standards/
                               testing-skill/

/agents      → __AGENT_DIR__/agents/speckit/{agent}.md
                       with skills: {framework}-architecture, etc.
```

Agents orchestrate workflows; skills provide expertise. Keep them complementary, not redundant.
